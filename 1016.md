메타 프로그래밍 - 코드를 데이터로 활용하는 프로그래밍 런타임시 동적으로 만들어내거나 그런것. 자바에는 리플렉션 패키지안에 그런게 들어있었다. 예전에 툴을 만들때 컴파일된 클래스 라이브러리 데이터를 화면에 보여줘야 되잖아요? 이런걸 데이터화 해야만 툴을 만들 수 있는데 이런데서 사용했던것이다. 아니면 6장의 다이나믹 프록시를 만들기 위해서도 리플렉션을 사용할 일이 있다.

CGLIB은 jdk 표준 라이브러리가 아니다. 하이버네이트 이런데서 막 다 사용하는데 핵심적인 이유는 인터페이스를 구현하지 않은 클래스에 대해서도 프록시를 만들때 CGLIB이 필요하다. 인터페이스를 항상 구현하지 않잖아요. 원래 jdk 리플렉션을 통해서 구현할 수 없다. cglib은 상속해서 프록시 오브젝트로 바꿔버린다. 우리가 만들지 않은 코드에 프록시를 적용할 때 이럴때는 cglib 을 어쩔수없이 적용해야한다. 그래서 스프링에선 다 쓰인다. jdk 다 참고해서 만들었기때문에 이름 다 비슷하다.

목은 적절히 잘 사용하면 아주 좋다. dao같은건 목을 아무리 써도 의미가 없는 그런 경우가 많다 그런애들은 통테할때 사용하면 좋다. 의존을 잘 격리해서 항상 동하게 동작하는 코드를 만들어야 한다.

제일 많이쓰는 @Transactional 이거 하나가 진짜 중요한데 애노테이션 안쓰고 프로그래머틱 트랜잭션 방식을 쓰자 이런 주장이 나오고 있는데 이런사용법도 있고 저런 사용법도 있다 같은 접근방법인데 이거는 트랜잭션 어트리뷰트 소스를 이용한 포인트컷 막 구현 접근방법중의 하나로 볼 수 있으면 조금 더 다양한 경험을 이해하는데 도움이 될 것 같습니다.

클래스로더는 말그대로 클래스를 읽어서 메모리에 올려서 클래스를 사용하게하는 케머니즘을 제공하는건데 톰캣이라든지 서버단에서 보면 하나의 클래스로더만 사용되지 않는다. jdk프록시를 써서 클래스를 동적으로 생성했으면, 없던 클래스를 생성했으니까 프로그램에서 사용되어질 수  있도록 클래스 로더를 하나를 지정을 해줘야한다. 그래서 하나 지정해서 이거를 사용해라 지정해줘야한다. 아무튼 동적으로 코드를 만드는 모든 종류의 기술을 클래스로더가 반드시 사용되어야하고 어떤걸 찾아 넣어야 하지? 고민할필요없다 스프링이 해준다.

jpa에서도 이것과 비슷한 프록시 기법을 사용한다 예를들어 manyToOne 사용할때 레이지로딩 설정하고 그러면 프록시가 읽힌다 이런거 다 들어보셨죠? 아니요… 여기서 이야기하는 프록시가 여기서 이야기하는 객체지향 디자인패턴에서는 프록시 패턴을 이야기하는것이다. 엔티티에 인터페이스 구현하는 방식으로 만들어보셨나요? 요즘엔 그렇게 안하죠 그래서 cglib을 사용했구요. 근데 이거 인터페이스로 사용하면 다이나믹프록시로 구현할 수 있다.

cglib은 성능하고는 생각보다 별로 상관이 없고요 왜냐하면 상속을 통해 프록시를 만드는건 비정상적 방법이다. 왜냐면 상속을 했기 때문에 서브클래스 인스턴스를 만들때 기본생성자를 호출해야하고 수퍼클래스 기본생성자를 호출해야하잖아요? 그러면 기본생성자가 두번 호출되는 현상이 일어나요. 또 하나는 파이널클래스로 만들수가 없다는것? 상속을 못하게 만들었으면 cglib을 쓸 수 없어요. 근데 이중에서 첫 번째 문제는 제네시스 오브젝트라이브러리 그런걸 사용해서 인스턴스를 만들때 생성자를 호출하지 않는 jvm구현체에 맞게 다 구현했다. 그게 스프링 5부터는 cglib을 통해 프록시 생성자 호출 2번 호출 문제가 없어졌다. 흥미로운이야기죠? 스프링6에서 제일 중요한건 네이티브 컴파일되는 기술 그랄vm인데 네이티브 컴파일 장벽중 하나는 리플렉션을 많이쓰는것이다. 리플렉션은 런타임중에 동적 코드 생성하는건데 네이티브하게 컴파일하면 적용하는게 어려운데 문제가 어디서 생기느냐보면 cglib같은 로우레벨의 기술을 사용하는 라이브러리와 충돌이 많이 일어난다 스프링 팀이 네이티브 컴파일러 컴파일 기능 적용하려고 노력했는데 스프링에서ㅗ  cglib을 없애야한다 이걸 없애고 다른방식을 적용해야한다 그런 이야기가 많이 나왔습니다. 사실 cglib이 좋은기술이라고 권장하지 않는다.

aspectj 바이트코드를 직접 조작해서 동적으로 오브젝트를 끼워넣는게 아니고 비즈니스코드 앞뒤에 갖다 박아버린다. 이러면 더 빠르다. 위빙이라고 하는데 컴파일된 클래스를 재컴파일하는방식 클래스 로드할 때 바꿔치는 방식 이런걸 사용한다. apm도 비슷한 원리를 이용하는데 클래스자체를 바꿔서 내용을 넣습니다.

코드 위빙 이 트래픽의 영향을 받을까?
메소드 호출이 한번 더 발생해서 일어나는 부하. 위빙을해서 컴파일해버리면 메소드 호출단계는 덜되지만 코드가중복되서 모든 클래스와 메소드에 다 들어가겠죠 그러면 파일이 커지니까 클래스 로드가 오래걸리겠죠? 사실 다 두가지 의미없다.
객체를 하나 더 만들고 메소드 호출 한개 더 하는거 이게 약간의 차이가 있긴하지만 이거 별로 의미가 없다. 시스템 만들어서 성능을 고민할때는 데이터베이스, 외부서비스와의 http콜같은거에서 발생하는 레이턴시, 요즘에 서버사이드 코드에서 json인코딩 디코딩하는 이게 진짜 리소스를 많이 잡아먹는다. 그거 제이슨 변환이 이게 성능을 엄청나게 먹는다 cpu를 많이 먹는다는 뜻이다. 아니면 IO가 길어져서 놀고있는거 이런게 문제지 사실 내부에서 오브젝트 한두개 호출 더하고 아무 의미없습니다. 정말 미미하기때문에 너무 궁금하면 그때 해도 늦지않다. 자 그럼 리팩토링할때 메소드 추출해서 메소드 콜이 하나 더 늘어났는데 그건 어떻게 생각할것인가? 이거에 대한 생각을 해보면 답이 나올것 같다.그런부분에대한 생각은 안하셔도 된다.옛날에야 small integer 사용하고 byte 이런거를 사용해서 메모리를 줄이고 cpu부하 줄이자 이랬지만 요즘엔 진짜 전체 시스템 성능을 논할만한 이야깃거리가 되지 않는다.

스프링의 트랜잭션 프록시 팩토리빈 aop처럼 한번 생성되면 이후에 바뀌지않고 사용되는것 이거는 성능에 큰 영향이 없어요 전체로 보면. 근데 테스트에서 목라이브러리 사용하는건 각 메소드마다 기본적인 옵션 테스트 라이프사이클이 매 메소드마다 새롭게만든다 이게 기본적인옵션인데 이러면 테스트마다 새롭게 만들어서 성능에 영향을 많이 준다. 목을 너무많이쓰면 per_class해서 한번만 만들게한다 이런 원칙을 적용하면 성능이 너무 많이 느려지면 좋을것 같다.
