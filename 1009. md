트랜잭션의 경계가 어디여야 한다 트,랜잭션의 경게는 서비스 앞단에 트랜잭션 경게를 거는게 중요하다. 이러지 않으면 dao에서 시작해야하는데 쿼리 날아갈때마다 트랜잭션 완료가되고 분리가 되는데 하나의 비즈니스로직은 단위없무로 작업으로 묶어서 전부다 되던지 아니면 아니든지 그렇게 경계를 서비스계층에 일정시점에 하는게 좋다는 것이다.

데이터소스 하이버네이트 동시에 사용가능한가? 당연히 한꺼번에 사용가능하다 필요하다면, 그리고 하나의 트랜잭션으로 묶을 수도 있다. 그게 어떻게 가능한가에 대한 내용은 이 책의 2부에 나온다.  tm 을 한가지로 적용하면 나머지도 다 그렇게 적용할 수 있다.

테스트 경곗값 이건 2장에 이야기를 했던것이다. 어떤걸 테스트할것이가를 생각해야하는데 실패하는 케이스를 제대로 생각하지 않으면 안된다.동등분할 ,분할의 경곗값을 기준으로 세팅하는것은 굉장히 좋은 접근방법이다. 

요즘엔 트랜잭션이 범위가 진자 넓어져서 일관성을 트랜잭션이 지켜주게 하는게 디비의 트랜잭션만 믿고 처리해야하는가 그 이상의 방법을 적용해야 하는가 마이크로서비스 다루는 이런 사람들이 자주 이야기하는 여기서는 트랜잭션이 범위가 더 넓어지고 그렇다.

스프링에서 무엇을 추상화해놓는가에 대해서 잘 살펴볼 필요가 있다.

예전에는 다 직접 트랜잭션 시작하는거를 서비스 계층에 트라이캐치 파이널리 만들어서 다 묶었었다. 스프링이 진짜 감쪽같이 신경쓰지 않고 개발하게 만들어준거다. 어디서 희한한 없었던 기술을 가져다 쓴게 아니라 객체지향 설계원칙 이런걸 조합해서 문제를 풀어나가는 트랜잭션을 다루는 기술까지 발견했다고 보면 된다.

어디선가 트랜잭션이 끊어졌다고 생각해보자. 트랜잭션 레벨이 기대한대로 셋팅이 안되어있기때문에 논리적인 버그가 생길 가능성이 높아진다. 그걸 찾기 위해 여러 서비스에 걸쳐서 일어나는 작업을 하나의 트랜잭션으로 묶었는지 디버깅 검증할 때가 분명히 오게 된다. 그래서 그때 아 스프링이 트랜잭션 어떻게 전파하고 관리가 되고있구나 이런걸 알고있으면 어디서 트랝개션 셋티ㅇ이 잘못됐네 이런걸 알 수 있다. 중요하다 디비안쓰는 앱은 없다.디비를 쓰는한 트랜잭션은 다 만들어지고있고 드트랜잭션으로 묶는거는 굉장히 중요하다.

외부 의존성을 없애는 방법은 페이트 서비스를 만드는 방법도 있고 API와이어 목이라던가 서버처럼 통신하면서 리얼서버와 비슷하게 원하는 셋팅값을 돌려주고 검증하는 단계에서 적용하는 방식 그런거를 되게 다양한 접근방법이 있는것 같다. 테스트는 코드를 바꾸지 않는 한 동일하게 값이 나와야한다. 되게많은회사들이 테스트서버를 제공을 한다. 골든마스터밸류 막 이런거 해서 결제금액을 100으로 해서 테스트서버에 요청하며ㅑㄴ 성공응ㄹ답을 한다 막 이런식으로 미리 셋팅되어있는 값이 있다. 서버가 응답하는것처럼 시나리오대로 되게 해주는 방법도 있다. 은행은 계좌이체 테스트서버가 없다 동남아시아 유며ㅛㅇ한 은행인데. 테스트서버 없는데 실제동작 확인하고싶은데 어떻게해야하나 그랬는데 운영서버에 돌리랬다. 이메일 보내서 트랜잭션 번호 테스트용으로 보낸거 실행시키지 말고 값만 확인해서 이메일로 돌려달라 문제없는지 수동으로 응답해주는 운영서버에서 직접 테스트를 하는 경우도 잇더라고요 좋은말로 놀라웠고 이게 말이되나 한 나라의 손가락꼽는 큰은행인데 이런식으로 해도되나 이랬는데 다양한 환경이 있는것 같다. 테스트는 어떻게든 할 수 있는 방법이 다양하게 있다.

욪요즘에 간혹 스프링빈에 상태값을 저장하고 그런사람들이 있어서 놀라는데 그걸 찾아내는 코드분석툴 이런것도 만들어내고 그러는데 수천명 쓰다보면 충돌이 발생하는데 그런것들 잘 피해야한다.

디비에 이늄타입 쓰는거는 절대 추천하지 않는다. 큰박재성이 말해서 썼는데 애를먹었다. 문자열이나 숫자로 변경해서 저장하는것을 추천한다.

톰캣은 대략 200개의 쓰레드 풀을 가지고있다 200명의 요청을 동시에 진행할 수 있다. 

네스티드쓰레드 중첩쓰레드를 분기하면서 쓰레드 로컬을 물고들어갈수있게 설정할 수 있다.여러개의 다 다른종류의 디비를 막 끌고와서 다른정보 가져와서 작업을 병렬로 처리했으면 좋겠다. 이런상황에서는 리액티브 웹플럭스 방법을 사용하면 된다 얘는 쓰레드가 다 분리가 된다. 하나의io를 요청한담에 돌아오는 네트워크 시간동안 최초로 요청 처리하면서 만든걸 반환하는 방법을 사용해서 다른요청을 처리하게 만든다. 이러면 뒷단의 시간오래걸리고 부하걸려도 되게 적은 쓰레드로 요청을 처리할 수 있다. 시피유 코어의 2배정도만 만들어놓고 200개 처리하는것보다 더 많은 요청들을 수행할 수 있다. 그경우에는 하나의 트랜잭션이 쭉 물리는게 여러쓰레드가 왔다갔다 하면서 병령적으로도 일어나는데 그런데도 트랜잭션이 잘 물려서 컨트롤될 수 있도록 다 만들어 놨다. 직접 만들고싶으면 웹플럭스의 스케쥴러를 사용해서 만드시는게 좋다.
