1. 캐모마일이 jpa를 사용하게 된 이유
    1. 웹 레이어 api제공에서 코드기반 서비스레이어 api제공방식으로 코드 변경 필요
    2. 지저분한 코드, 객체지향적이지 않은 도메인, 비즈니스 로직. 이참에 바꾸고 광명찾자!
2. 캐모마일이 queryDSL을 사용하게 된 이유
    1. 비즈니스 로직을 도메인로직으로 이동시키면서 작업을 진행할 수 있으나… 사이즈가 말이 안되는것들도 많고… 쿼리도 이상하고
    2. 그래서 동적쿼리를 작성하기 쉬운 queryDSL을 적용하기로 결정
3. queryDSL을 사용하며 겪었던 문제점 및 불편했던 점.
    1. 그러나 모든것이 다 해결되는것은 아니었으니…
    2. 리플렉션을 이용한 컴파일타임의 Q파일 생성. 해당 객체를 기반으로 한 쿼리 작성.
    3. 어느 정도 예측은 가지만 직접 쿼리를 날려보기 전까지 완전 정확하게 쿼리가 어떻게 날아갈지 모른다.
    4. 안되는 기능들이 있네? groupBy / fetchResults 동시 사용 불가 이슈.
    5. 서브쿼리 사용할 수 있긴 한데 너무 불편하다. 결국 조인을 사용해서 동일한 쿼리가 날아가는지 테스트로 빡빡하게 검증해야했다.
4. queryDSL을 사용할때 주의해야 할 점.
    1. N+1문제
    2. fetchJoin과 pagenation을 동시에 사용한다면?
5. 대안은 없었는가? 이제와서 생각하는 더 좋았을만한 방법.
    1. 사실 우리에겐 jpa가 별로 필요 없었을지도 모르겠다.
    2. 딱히 재사용 할만한 복잡하고 특별한 비즈니스 로직이 없고 단순한 일반 쿼리로 이루어진 서비스이기 때문에 spring data jdbc가 더 좋았던 선택이었을지도 모르겠다. 지금보면 딱히 특별한 데이터베이스 함수를 호출하거나 그런 기능들은 없었다. 괜히 지레 겁먹고 여러 버전의 쿼리를 작성해야 할지도 모른다는 두려움에 일을 복잡하게 만든것 같다.
    3. 우린 그러면 Q파일도 같이 포함해서 배포를 진행해야하나? 그런 의문점도 있다. 그러면 해당 파일이 외부로 노출될텐데… 이걸 어떻게 해결할지 의문
