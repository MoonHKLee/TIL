서비스 로케이터 ? 빈으로 등록될수 없는 객체라면 getBean을 해서 의존성을 가져와 사용할 수도 있다. 근데 이거 진짜 이런용도로 특별한 용도로 사용하는게 아니면 사용하지 말아야 할 안티패턴이다.

DI는 인터페이스를 꼭 써야하나?
ex ) List<Integer> = new ArrayList<>();
서비스객체는 인터페이스를 안만드는 사람들이 많이 있는데 굉장히 이상한 방법으로 적용하는것이다. 구현이 바뀌면 읜존하는쪽의 코드도 같이 변경해야하는데 그럴거면 new 로 생성해서 받아라. 토비님은 그런면에서 인터페이스를 꼭 사용해야 한다고 생각한다. 클래스로 만든걸 인터페이스 비슷하게 사용하는 방법이 있다. CGLIB으로 프록시를 만들고 이것을 사용해서 DI를 한다. 이거는 조금 억지라고 본다. DI를 사용할거면 인터페이스를 사용하는게 좋다고 생각한다. 안써도 된다 이런식으로 시작을 하게되면 모든것이 그렇게 안해도 되는데? 라는 식으로 방향이 진행된다. 내가 의존하고 있는 객체에 영향을 받지 않기 위한것인데, 클래스에다 메소드를 많이 만들엇는데 이게 구현에 필요해서 만들어놓은 메소드인지 구분이 나중에 잘 안되고 짬뽕이 된다. 그래서 명확하게 인터페이스로 외부로 노출되는것을 다만드는것이 좋다. 이걸 안만든다? 아주잘못하고있어. 그러건 아니지만 만드는게 중요하다고 말씀 드리고싶다. 컨트롤러에다가는 인터페이스를 안만든다. 서비스는 트랜잭션을 적용하면 그 의존하는 대상이 변경한다. 프록시가 생성하면서. 작은 단위로 구성을 하다보면 여러가지 의존 구조를 만드는게 좋다. 누군가 나에게 읜존하고있다면 외부에 공유하는걸 적극적으로 알릴 필요가 있다. 모든 클래스는 구현 초기에 복잡하지 않다. 그러나 시간이 지나면 지날수록 결국 복잡해지고 읽기 어려워진다. DI할 객체는 일단 인터페이스를 만들자. 자바의 리스트 구현체가 미래에 바뀌겠어요? 안바뀌어요 코드에서 구현 바꾼다고 하더라도 우리가 만든 클래스가 아니기때문에 영향을 받지 않는다. 직접 내가 new할것인가. DI할것인가 그것에 대해서 생각하는게 필요하다. 내가 외부에 노출할 것이 무엇인가. 내가 숨길것을 무엇인가에 대해 생각을 시작하게 만드는 설계이다. 솔리드원칙에도 인터페이스 클라이언트마다 구분해서 만들라고 한다. 인터페이스를 설계하는것을 흥미롭게 고민해볼 필요가 있고 나중에 의존관계를 분석해서 클래스를 분리할 수도 있다. 처음에 코드를 20 30개 만들때랑 1000개 될때랑 다르다. 인터페이스를 만들어서 문제가 될 것은 없지만 인터페이스를 만만들었을때 문제가 되는 경우는 있다.

생성자주입 vs 세터주입

토프링에서는 세터주입의 장점을 보여주고있는데 이게맞나?

생성자를 쓰는것을 스프링도 권장을 한다. 세터가 자연스러운것은 자바빈이라는 기본 적으로 프로퍼티 베이스로 설계되어있어서 세터를 이용해 속성을 변경하는 자바 기본 개발 흐름이다. 세터를 사용하는게 자연스러웠다. 그때는. 세터는 의존관계를 설정할 수도 있고 안할수도있고 그럴때만 세터를 사용한다. 심지어는 인텔리제이에서 워닝이 뜨기도 한다. 생성자의 가장 큰 단점은 타입이 다 다르지 않으면 순서가 뒤바뀌어도 체크가 안된다. 같은 타입이 2개있으면 그걸 체크를 할수가 없다. 사실 자바에서 생성자메소드의 그 파라미터 이름을 체크할 수 있게 된지 얼마 안되었다. 정확한 타입을 넣지 않으면 엉뚱한 빈을 넣으면 순서가 뒤바뀌어도 검증이 안되는 문제가 있었다. 반면에 세터는 이름기반으로 명시적으로 프로퍼티 이름을 사용했으니까 실수가 만들어질 확률이 앉았다. 중간에 의존관계를 바꾼다? 그런코딩은 하지 않는다. 문제는 오브젝트의 생명주기, 오브젝트가 만들어졌어 이걸 사용하는 중이야 이건 파괴하는중이야 ㄱgc할거야 이런 ㅅ애명주기가있다. 컨테이너가 오브젝트를 만들었다라는 그 시기를 어디로 끊을것이야 라는 관점을 세터메소드 생성까지 다 마치고 밸리데이션마치고 나면 준비가 된거다 생성하는 . 생성자메소드도 한방에 만들어지나? 사실 동시성 처리 공부하다보면 그게 다 쪼개져있는 작업이고, 인스턴스가 만들어지는 중간에 어떤것을 방어할것인가 그런것도 있다. 오브젝트의 생성컨셉에 따라서 어떻게 접근해도 상관없다. 중요한것은 유행하는게 뭐냐. 그거를 따라가면 되는데 한번 생성되면 final로 못바꾸게 한다. 사실 final로 안해도 문제 안생긴다. 그럼에도 불구하고 코드레벨에서 엄격하게 실수를 원천 차단하는 게 트렌드이기 때ㅑ문에 생성자 주입 적극적 사용을 권장한다. 생성자주입을 쓰세요 웬만하면. 동일한 타입 2개 이런거는 막을 수 있는 패턴이 있다. 세터주입을 보고 틀렸네 이렇게 생각할 필요는 없다.  자바빈 전통에서 시작한 자연스러운 흐름이다. 코틀린쓰면 편한게 코틀린은 디폴트를 줄수있어서 좋다. 

컨트롤러는 상태를 가지면 안되나요? 원래 객체지향에서 객체는 상태랑 행위를 같이 가지고있는게 객체인데? 도메인 오브젝트같은경우에는 게터세터 안만들고 그런건 맞는데 서비스 컨트롤러같은경우는 아예 상태를 안가지는데 게터세터 사용해도 상관없다. 그냥 초기화를 위한 작업 그거 한번 쓰고 마는거다. 빈으로 등록되는

이 빈이 다른  빈에 의존관계를 가지고있기 때문에 빈으로 등록을 하는데 하나만 만들지 않는 경우는 특별한 스코프를 갖는 경우가 있다 예를들어 session스코프. 세션 레벨마다 하나의 빈을 따로 가질수 있게 하면 조금 유리한 점이 있지 않을까? 세션 스코프마다 독립적인 빈이 만들어지게 할 수 있다. 그러면 그때는 상태를 가질 수가 있네? 근데 잘 안씁니다. 그렇게 한 서버안에 스코프안에 하나의 빈 유지되게 만드는것 그건 서버 인스턴스를 한개만 쓴다는 가정하에 진행된다. 보통 레디스나 이런쪽으로 빼버리고 아니면 클라이언트쪽으로 빼는게 더 좋다. 상태는 오로지 의존관계만 가지고있게 만든다.

XML? 파일만 고치면 빌드를 안해도 된다 컴파일 안해도 됨 개이득! 굉장히 혁신적인 방법이었다. 근데 이제 치명적인 단점이 있는데 여러사람이 동시에 개발을 하면 너랑 나랑 다른걸 만드는데 나도고치고 너도고치면 기본적으로 하나만있다고치면 두사람이 동시에 고친다음에 푸쉬하면 충돌난다. 머지 이거 잘 안되면 진짜 어지럽다. 옛날에는 깃도 없어서 진짜 어지럽다. xml단점으로 타입체크를 런타임에 하기때문에 띄워봐야 한다는 단점도 있다. 물론 인텔리제이는 그걸 에디터에서 체크해서 알려준다. 에러메시지로. 그냥 좋은 에디터를 쓰면 해결할 수 있는 부분인다. 또 서버를 띄울 때 알 수 있기때문에 그렇게 큰 문제는 아니다. 그런데 추세는 xml을 안쓰는 추세이다. xml만은 급하게 고쳐서 적용할 경우에 코드를 컴파일 하지 않는다는게 옛날엔 굉장히 큰 장점이다. 지금은 ci/cd이런게 당연한데 옛날에는 직접들어가서 빌드했다.

애노테이션이 먼저생겼을까요 스프링이 먼저생겼을까여 스프링이 먼저 나왔습니다.애노테이션은 2005년에 나왓다. 애노테이션이 나오고나서 자바개발자들은 와 이거 좋은데 환호를 했지만 과도하게 사용이 되고 애노테이션에 코드 자체와 직접적 관계가 없는 부가적 정보가 들어가는 반발로 애노테이션 과도하게 사용하지 말자 이런 이야기가 나오고 있다. jpa에 원래 만든 사람들의 아이디어는 디비 매핑정보는 xml로 엔티티 정보는 애노테이션으로가 기본 원했던 방식이다. 근데 애노테이션이 편하니까 과도하게 애노테이션에 들어가지 말아야 할 부분까지 다들어가는데 많은분들이 또 좋아하기때문에 어렵다

@과 xml의 가장 큰 차이점은 뭐라고 생각하세요?

@을 쓰면 정보 하나를 생략할 수 있다.애노테이션은 클래스 이름을 명시하지 않아도 된다. xml이라면 FQCN을 기입해야한다. 애노테이션은 코드가 더 단순화되고 실수할 가능성이 줄어든다. 자바 클래스의 메타정보를 다 읽어다가 쓸수있다. 하이버네이트를 설계한 개발자는 xml은 코드 중복이다 이런 말을 했다. 모든걸 다 @을 써야한다고까지 주장했다. 어이가 없으면서도 애노테이션에 대한 사랑이 느껴지긴했다. 몰아넣기 vs 분리하기 이건 끊임없는 주제이다. 얼마나 분리할래? 얼마나 모아둘까? 이런것은 많은 기준을 가지고 이야기를 해보고 방법을 찾아가는것일 뿐 정답은 없다.

xml파일이 커지면 xml보다가 시간이 다간다. 트렌드는 xml을 안쓰는게 트렌드입니다.

코드에서의 의존관계와 런타임시에 의존관계 만들어지는것 이 2가지를 구분하는게 객체지향의 핵심중의 핵심이다. 이것만 잘 느껴도 1장은 얻어가신것이다.

싱글톤 패턴 싱글톤 레지스트리 어떤게 더 빠를까? 싱글톤 패턴은 계속 lookup을 한다. 빈으로 등록하면 최초 등록 이후 lookup 없이 활용할 수 있다. 싱글톤레지스트리가 성능상에 더 좋긴 한데 사실 아무 의미없다. 성능에 의미있는 영향을 주지 못한다.

싱글톤패턴의 한계를 보완하기 위해 싱글톤 레지스트리가 있는걸로 알고있다. 싱글톤 레지스트리는 한개만 생성된다고 보장할수 있는가? 에대한 의문이 있다. 

톰캣같은 서버내에는 여러개의 애플리케이션이 배포될수잇는데 각각에 올리때마다 클래스 로더가 따로 올라ㅣ간다., 클래ㅔ스 로더 위에서 클래스가 만들어지기 대문에 1개 이상이 되기도 합니다.

스프링은 그걸 극복하기 위해 만든건 아니고 자기가 직접 빈을 만들고 싱글톤으로 관리하겠다고 그런 목적을 만들기때문인것이지 싱글톤패턴의 단점을 극복을 하기 위한것은 아니다. 심지어 스프링은 프라이빗 생성자를 가진 클래스도 빈으로 등록해준다. 

스트럿츠는 커맨드 패턴을 사용해서 요청이 들어올때마다 커맨드를 만들어서 실행하게 만들었다. 요청마다 새로운 오브젝트를 생성하는 독특한 방법으로 만들어지기도 했다. 

스프링의 최대 단점은 1.0.부터 6.0까지 각자 스프링을 보는 방식이 다르다는것이다. 스프링 망하고 좀 더재밌는거 나왔으면 좋겠다 하는데 아진짜 다 맥을 못추더라고요 스프링을 위협할게 없어요 자바는자바 망하기전까지 스프링을 갈것인가 이런 생각을 하고있다.
